<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Daniel C. Jones, Connor T. Skennerton" />
  <meta name="dcterms.date" content="2020-11-16" />
  <title>Mk(1)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mk(1)</h1>
<p class="author">Daniel C. Jones, Connor T. Skennerton</p>
<p class="date">November 16, 2020</p>
</header>
<h1 id="name">NAME</h1>
<p>mk - maintain (make) related files</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><code>mk [ -f mkfile ] ...  [ option ... ] [ target ... ]</code></p>
<h1 id="description">DESCRIPTION</h1>
<p><code>Mk</code> uses the dependency rules specified in mkfile to control the update (usually by compilation) of targets (usually files) from the source files upon which they depend. The mkfile (default <code>mkfile</code>) contains a rule for each target that identifies the files and other targets upon which it depends and a script or recipe, to update the target. The script is run if the target does not exist or if it is older than any of the files it depends on. Mkfile may also contain meta-rules that define actions for updating implicit targets. If no target is specified, the target of the first rule (not meta-rule) in mkfile is updated.</p>
<p>Options are:</p>
<dl>
<dt>-f</dt>
<dd>use the given file as mkfile. default is <em>mkfile</em>
</dd>
<dt>-n</dt>
<dd>print commands without actually executing
</dd>
<dt>-r</dt>
<dd>force building of just targets
</dd>
<dt>-a</dt>
<dd>force building of all dependencies
</dd>
<dt>-p</dt>
<dd>maximum number of jobs to execute in parallel. Default is the number of CPUs
</dd>
<dt>-i</dt>
<dd>prompt before executing rules
</dd>
<dt>-q</dt>
<dd>don’t print recipes before executing them
</dd>
</dl>
<h2 id="the-mkfile">The mkfile</h2>
<p>A mkfile consists of assignments (described under `Environment’) and rules. A rule contains targets and a tail. A target is a literal string and is normally a file name. The tail contains zero or more prerequisites and an optional recipe. Each line of the recipe must begin with white space. A rule takes the form</p>
<pre><code>target: prereq1 prereq2
        recipe using prereq1, prereq2 to build target</code></pre>
<p>After the colon on the target line, a rule may specify attributes, described below.</p>
<p>A meta-rule has a target of the form A%B where A and B are (possibly empty) strings. A meta-rule acts as a rule for any potential target whose name matches A%B with % replaced by an arbitrary string, called the stem. In interpreting a meta-rule, the stem is substituted for all occurrences of % in the prerequisite names. In the recipe of a meta-rule, the environment variable <code>$stem</code> contains the string matched by the %. For example, a meta-rule to compile a C program using might be:</p>
<pre><code>%: %.c
    cc -o $stem $stem.c</code></pre>
<p>The text of the mkfile is processed as follows. Lines beginning with <code>&lt;</code> followed by a file name are replaced by the contents of the named file. Lines beginning with <code>&lt;|</code> followed by a file name are replaced by the output of the exe- cution of the named file. Blank lines and comments, which run from unquoted <code>#</code> characters to the following newline, are deleted. The character sequence backslash-newline is deleted, so long lines in mkfile may be folded. Non-recipe lines are processed by substituting for <code>{command}</code> the output of the command when run by rc. References to variables are replaced by the variables’ values.</p>
<p>Assignments and rules are distinguished by the first unquoted occurrence of <code>:</code> (rule) or <code>=</code> (assignment).</p>
<p>A later rule may modify or override an existing rule under the following conditions:</p>
<ul>
<li>If the targets of the rules exactly match and one rule contains only a prerequisite clause and no recipe, the clause is added to the prerequisites of the other rule. If either or both targets are virtual, the recipe is always executed.</li>
<li>If the targets of the rules match exactly and the prerequisites do not match and both rules contain recipes, <code>mk</code> reports an “ambiguous recipe” error.</li>
<li>If the target and prerequisites of both rules match exactly, the second rule overrides the first.</li>
</ul>
<h3 id="environment">Environment</h3>
<p>Rules may make use of environment variables. A legal reference of the form <code>$OBJ</code> is expanded. A reference of the form <code>${name:A%B=C%D}</code>, where A, B, C, D are (possibly empty) strings, has the value formed by expanding <code>$name</code> and substituting C for A and D for B in each word in <code>$name</code> that matches pattern A%B.</p>
<p>Variables can be set by assignments of the form</p>
<pre><code>var=[attr=]value</code></pre>
<p>Blanks in the value break it into words, but without the surrounding parentheses. Such variables are exported to the environment of recipes as they are executed, unless U, the only legal attribute attr, is present. The initial value of a variable is taken from (in increasing order of precedence) the default values below, mk’s environment, the mkfiles, and any command line assignment as an argument to mk. A variable assignment argument overrides the first (but not any subsequent) assignment to that variable.</p>
<p>The variable MKFLAGS contains all the option arguments (arguments starting with ‘-’ or containing ‘=’) and MKARGS contains all the targets in the call to mk.</p>
<h3 id="execution">Execution</h3>
<p>During execution, mk determines which targets must be updated, and in what order, to build the names specified on the command line. It then runs the associated recipes.</p>
<p>A target is considered up to date if it has no prerequisites or if all its prerequisites are up to date and it is newer than all its prerequisites. Once the recipe for a target has executed, the target is considered up to date.</p>
<p>The date stamp used to determine if a target is up to date is computed differently for different types of targets. If a target is virtual (the target of a rule with the V attribute), its date stamp is initially zero; when the target is updated the date stamp is set to the most recent date stamp of its prerequisites. Otherwise, if a target does not exist as a file, its date stamp is set to the most recent date stamp of its prerequisites, or zero if it has no prerequisites. For URLs the <code>Last-Modified</code> header returned from a HTTP HEAD request is used to determine if the target is up to date. Otherwise, the target is the name of a file and the target’s date stamp is always that file’s modification date. The date stamp is computed when the target is needed in the execution of a rule; it is not a static value.</p>
<p>Nonexistent targets that have prerequisites and are themselves prerequisites are treated specially. Such a target <code>t</code> is given the date stamp of its most recent prerequisite and if this causes all the targets which have <code>t</code> as a prerequisite to be up to date, <code>t</code> is considered up to date. Otherwise, <code>t</code> is made in the normal fashion.</p>
<p>Files may be made in any order that respects the preceding restrictions.</p>
<p>A recipe is executed by supplying the recipe as standard input to the command, <code>sh</code>, unless The <code>S</code> attribute is set, which defines an alternative program to run the recipe</p>
<p>The environment is augmented by the following variables:</p>
<dl>
<dt>$alltarget</dt>
<dd>all the targets of this rule.
</dd>
<dt>$newprereq</dt>
<dd>the prerequisites that caused this rule to execute.
</dd>
<dt>$newmember</dt>
<dd>the prerequisites that are members of an aggregate that caused this rule to execute. When the prerequisites of a rule are members of an aggregate, $newprereq contains the name of the aggregate and out of date members, while $newmember contains only the name of the members.
</dd>
<dt>$nproc</dt>
<dd>the process slot for this recipe. It satisfies 0≤<span class="math inline"><em>n</em><em>p</em><em>r</em><em>o</em><em>c</em>&lt;</span>NPROC.
</dd>
<dt>$pid</dt>
<dd>the process id for the mk executing the recipe.
</dd>
<dt>$prereq</dt>
<dd>all the prerequisites for this rule.
</dd>
<dt>$stem</dt>
<dd>if this is a meta-rule, $stem is the string that matched % or &amp;. Otherwise, it is empty. For regular expression meta-rules (see below), the variables <code>stem0, ..., stem9</code> are set to the corresponding subexpressions.
</dd>
<dt>$target</dt>
<dd>the targets for this rule that need to be remade.
</dd>
</dl>
<p>These variables are available only during the execution of a recipe, not while evaluating the mkfile.</p>
<p>Unless the rule has the Q attribute, the recipe is printed prior to execution with recognizable environment variables expanded. Commands returning nonempty status cause <code>mk</code> to terminate.</p>
<p>Recipes and backquoted commands in places such as assignments execute in a copy of mk’s environment; changes they make to environment variables are not visible from mk.</p>
<p>Variable substitution in a rule is done when the rule is read; variable substitution in the recipe is done when the recipe is executed. For example:</p>
<pre><code>bar = a.c
foo: $bar
        $CC -o foo $bar
bar = b.c</code></pre>
<p>will compile b.c into foo, if a.c is newer than foo.</p>
<h3 id="aggregates">Aggregates</h3>
<p>Names of the form a(b) refer to member b of the aggregate a. Currently, the only aggregates supported are ar(1) archives.</p>
<h3 id="attributes">Attributes</h3>
<p>The colon separating the target from the prerequisites may be immediately followed by attributes and another colon. The attributes are:</p>
<dl>
<dt>D</dt>
<dd>If the recipe exits with a non-null status, the target is deleted.
</dd>
<dt>E</dt>
<dd>Continue execution if the recipe draws errors.
</dd>
<dt>N</dt>
<dd>If there is no recipe, the target has its time updated.
</dd>
<dt>n</dt>
<dd>The rule is a meta-rule that cannot be a target of a virtual rule. Only files match the pattern in the target.
</dd>
<dt>P</dt>
<dd>The characters after the P until the terminating : are taken as a program name. It will be invoked as rc -c prog ‘arg1’ ‘arg2’ and should return a null exit status if and only if arg1 is up to date with respect to arg2. Date stamps are still propagated in the normal way. This attribute is not compatible with the S attribute.
</dd>
<dt>S</dt>
<dd>Characters after S until the terminating : are taken as a program name. This program will be used to execute the recipe. This attrbiute is not compatible with the P attribute.
</dd>
<dt>Q</dt>
<dd>The recipe is not printed prior to execution.
</dd>
<dt>R</dt>
<dd>The rule is a meta-rule using regular expressions. In the rule, % has no special meaning. The target is interpreted as a regular expression as defined in regexp(6). The prerequisites may contain references to subexpressions in form .
</dd>
<dt>U</dt>
<dd>The targets are considered to have been updated even if the recipe did not do so.
</dd>
<dt>V</dt>
<dd>The targets of this rule are marked as virtual. They are distinct from files of the same name.
</dd>
</dl>
<h1 id="examples">EXAMPLES</h1>
<p>A simple mkfile to compile a program:</p>
<pre><code>&lt;/$objtype/mkfile

prog:   a.$O b.$O c.$O
        $LD $LDFLAGS -o $target $prereq

%.$O:   %.c
        $CC $CFLAGS $stem.c</code></pre>
<p>Override flag settings in the mkfile:</p>
<pre><code>% mk target &#39;CFLAGS=-S -w&#39;</code></pre>
<p>Maintain a library:</p>
<pre><code>libc.a(%.$O):N: %.$O
libc.a: libc.a(abs.$O) libc.a(access.$O) libc.a(alarm.$O) ...
        ar r libc.a $newmember</code></pre>
<p>String expression variables to derive names from a master list:</p>
<pre><code>NAMES=alloc arc bquote builtins expand main match mk var word
OBJ=${NAMES:%=%.$O}</code></pre>
<p>Regular expression meta-rules:</p>
<pre><code>([^/]*)/(.*)\.$O:R:  $stem1/$stem2.c
        cd $stem1; $CC $CFLAGS $stem2.c</code></pre>
<p>A correct way to deal with yacc(1) grammars. The file lex.c includes the file x.tab.h rather than y.tab.h in order to reflect changes in content, not just modification time.</p>
<pre><code>lex.$O: x.tab.h
x.tab.h:        y.tab.h
        cmp -s x.tab.h y.tab.h || cp y.tab.h x.tab.h
y.tab.c y.tab.h:        gram.y
        $YACC -d gram.y</code></pre>
<p>The above example could also use the P attribute for the x.tab.h rule:</p>
<pre><code>x.tab.h:Pcmp -s:        y.tab.h
        cp y.tab.h x.tab.h</code></pre>
<h1 id="see-also">SEE ALSO</h1>
<p>A. Hume, “Mk: a Successor to Make”.</p>
<p>Andrew G. Hume and Bob Flandrena, “Maintaining Files on Plan 9 with Mk”.</p>
<p>Most of the content of this manual is copied from the Plan 9 mk manual available here: http://man.cat-v.org/plan_9/1/mk</p>
<h1 id="bugs">BUGS</h1>
</body>
</html>
